; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --check-attributes --check-globals
; RUN: opt -aa-pipeline=basic-aa -passes=attributor -attributor-manifest-internal  -attributor-max-iterations-verify -attributor-annotate-decl-cs -attributor-max-iterations=3 -S < %s | FileCheck %s --check-prefixes=CHECK,TUNIT
; RUN: opt -aa-pipeline=basic-aa -passes=attributor-cgscc -attributor-manifest-internal  -attributor-annotate-decl-cs -S < %s | FileCheck %s --check-prefixes=CHECK,CGSCC

@GInt1 = internal global i32 undef, align 4
@GInt2 = internal global i32 zeroinitializer, align 4
@GInt3 = internal global i32 undef, align 4
@GInt4 = internal global i32 zeroinitializer, align 4
@GInt5 = internal global i32 undef, align 4

declare void @llvm.assume(i1)
declare void @useI32(i32)
declare void @unknown()

;.
; CHECK: @[[GINT1:[a-zA-Z0-9_$"\\.-]+]] = internal global i32 undef, align 4
; CHECK: @[[GINT2:[a-zA-Z0-9_$"\\.-]+]] = internal global i32 0, align 4
; CHECK: @[[GINT3:[a-zA-Z0-9_$"\\.-]+]] = internal global i32 undef, align 4
; CHECK: @[[GINT4:[a-zA-Z0-9_$"\\.-]+]] = internal global i32 0, align 4
; CHECK: @[[GINT5:[a-zA-Z0-9_$"\\.-]+]] = internal global i32 undef, align 4
;.
define internal void @write1ToGInt1() {
; CHECK: Function Attrs: nofree norecurse nosync nounwind willreturn writeonly
; CHECK-LABEL: define {{[^@]+}}@write1ToGInt1
; CHECK-SAME: () #[[ATTR1:[0-9]+]] {
; CHECK-NEXT:    store i32 1, ptr @GInt1, align 4
; CHECK-NEXT:    ret void
;
  store i32 1, ptr @GInt1
  ret void
}

define internal void @write1ToGInt2() {
; CHECK: Function Attrs: nofree norecurse nosync nounwind willreturn writeonly
; CHECK-LABEL: define {{[^@]+}}@write1ToGInt2
; CHECK-SAME: () #[[ATTR1]] {
; CHECK-NEXT:    store i32 1, ptr @GInt2, align 4
; CHECK-NEXT:    ret void
;
  store i32 1, ptr @GInt2
  ret void
}

define void @entry1(i1 %c, i32 %v) {
; CHECK-LABEL: define {{[^@]+}}@entry1
; CHECK-SAME: (i1 [[C:%.*]], i32 [[V:%.*]]) {
; CHECK-NEXT:    [[L0:%.*]] = load i32, ptr @GInt1, align 4
; CHECK-NEXT:    call void @useI32(i32 [[L0]])
; CHECK-NEXT:    call void @write1ToGInt1() #[[ATTR2:[0-9]+]]
; CHECK-NEXT:    [[L1:%.*]] = load i32, ptr @GInt1, align 4
; CHECK-NEXT:    call void @useI32(i32 [[L1]])
; CHECK-NEXT:    br i1 [[C]], label [[T:%.*]], label [[F:%.*]]
; CHECK:       T:
; CHECK-NEXT:    store i32 [[V]], ptr @GInt1, align 4
; CHECK-NEXT:    call void @useI32(i32 [[V]])
; CHECK-NEXT:    br label [[F]]
; CHECK:       F:
; CHECK-NEXT:    [[L3:%.*]] = load i32, ptr @GInt1, align 4
; CHECK-NEXT:    call void @useI32(i32 [[L3]])
; CHECK-NEXT:    call void @write1ToGInt1() #[[ATTR2]]
; CHECK-NEXT:    [[L4:%.*]] = load i32, ptr @GInt1, align 4
; CHECK-NEXT:    call void @useI32(i32 [[L4]])
; CHECK-NEXT:    ret void
;
  %l0 = load i32, ptr @GInt1
  call void @useI32(i32 %l0)
  call void @write1ToGInt1();
  %l1 = load i32, ptr @GInt1
  call void @useI32(i32 %l1)
  br i1 %c, label %T, label %F
T:
  store i32 %v, ptr @GInt1
  %l2 = load i32, ptr @GInt1
  call void @useI32(i32 %l2)
  br label %F
F:
  %l3 = load i32, ptr @GInt1
  call void @useI32(i32 %l3)
  call void @write1ToGInt1();
  %l4 = load i32, ptr @GInt1
  call void @useI32(i32 %l4)
  ret void
}

define void @entry2(i1 %c, i32 %v) {
; CHECK-LABEL: define {{[^@]+}}@entry2
; CHECK-SAME: (i1 [[C:%.*]], i32 [[V:%.*]]) {
; CHECK-NEXT:    [[L0:%.*]] = load i32, ptr @GInt2, align 4
; CHECK-NEXT:    call void @useI32(i32 [[L0]])
; CHECK-NEXT:    call void @write1ToGInt2() #[[ATTR2]]
; CHECK-NEXT:    [[L1:%.*]] = load i32, ptr @GInt2, align 4
; CHECK-NEXT:    call void @useI32(i32 [[L1]])
; CHECK-NEXT:    br i1 [[C]], label [[T:%.*]], label [[F:%.*]]
; CHECK:       T:
; CHECK-NEXT:    store i32 [[V]], ptr @GInt2, align 4
; CHECK-NEXT:    call void @useI32(i32 [[V]])
; CHECK-NEXT:    br label [[F]]
; CHECK:       F:
; CHECK-NEXT:    [[L3:%.*]] = load i32, ptr @GInt2, align 4
; CHECK-NEXT:    call void @useI32(i32 [[L3]])
; CHECK-NEXT:    call void @write1ToGInt2() #[[ATTR2]]
; CHECK-NEXT:    [[L4:%.*]] = load i32, ptr @GInt2, align 4
; CHECK-NEXT:    call void @useI32(i32 [[L4]])
; CHECK-NEXT:    ret void
;
  %l0 = load i32, ptr @GInt2
  call void @useI32(i32 %l0)
  call void @write1ToGInt2();
  %l1 = load i32, ptr @GInt2
  call void @useI32(i32 %l1)
  br i1 %c, label %T, label %F
T:
  store i32 %v, ptr @GInt2
  %l2 = load i32, ptr @GInt2
  call void @useI32(i32 %l2)
  br label %F
F:
  %l3 = load i32, ptr @GInt2
  call void @useI32(i32 %l3)
  call void @write1ToGInt2();
  %l4 = load i32, ptr @GInt2
  call void @useI32(i32 %l4)
  ret void
}
define void @entry3(i1 %c, i32 %v) {
; CHECK-LABEL: define {{[^@]+}}@entry3
; CHECK-SAME: (i1 [[C:%.*]], i32 [[V:%.*]]) {
; CHECK-NEXT:    [[L0:%.*]] = load i32, ptr @GInt3, align 4
; CHECK-NEXT:    call void @useI32(i32 [[L0]])
; CHECK-NEXT:    store i32 1, ptr @GInt3, align 4
; CHECK-NEXT:    call void @useI32(i32 noundef 1)
; CHECK-NEXT:    br i1 [[C]], label [[T:%.*]], label [[F:%.*]]
; CHECK:       T:
; CHECK-NEXT:    store i32 [[V]], ptr @GInt3, align 4
; CHECK-NEXT:    call void @useI32(i32 [[V]])
; CHECK-NEXT:    br label [[F]]
; CHECK:       F:
; CHECK-NEXT:    [[L3:%.*]] = load i32, ptr @GInt3, align 4
; CHECK-NEXT:    call void @useI32(i32 [[L3]])
; CHECK-NEXT:    store i32 1, ptr @GInt3, align 4
; CHECK-NEXT:    call void @useI32(i32 noundef 1)
; CHECK-NEXT:    ret void
;
  %l0 = load i32, ptr @GInt3
  call void @useI32(i32 %l0)
  store i32 1, ptr @GInt3
  %l1 = load i32, ptr @GInt3
  call void @useI32(i32 %l1)
  br i1 %c, label %T, label %F
T:
  store i32 %v, ptr @GInt3
  %l2 = load i32, ptr @GInt3
  call void @useI32(i32 %l2)
  br label %F
F:
  %l3 = load i32, ptr @GInt3
  call void @useI32(i32 %l3)
  store i32 1, ptr @GInt3
  %l4 = load i32, ptr @GInt3
  call void @useI32(i32 %l4)
  ret void
}

define void @entry4(i1 %c, i32 %v) {
; CHECK-LABEL: define {{[^@]+}}@entry4
; CHECK-SAME: (i1 [[C:%.*]], i32 [[V:%.*]]) {
; CHECK-NEXT:    [[L0:%.*]] = load i32, ptr @GInt4, align 4
; CHECK-NEXT:    call void @useI32(i32 [[L0]])
; CHECK-NEXT:    store i32 1, ptr @GInt4, align 4
; CHECK-NEXT:    call void @useI32(i32 noundef 1)
; CHECK-NEXT:    br i1 [[C]], label [[T:%.*]], label [[F:%.*]]
; CHECK:       T:
; CHECK-NEXT:    store i32 [[V]], ptr @GInt4, align 4
; CHECK-NEXT:    call void @useI32(i32 [[V]])
; CHECK-NEXT:    br label [[F]]
; CHECK:       F:
; CHECK-NEXT:    [[L3:%.*]] = load i32, ptr @GInt4, align 4
; CHECK-NEXT:    call void @useI32(i32 [[L3]])
; CHECK-NEXT:    store i32 1, ptr @GInt4, align 4
; CHECK-NEXT:    call void @useI32(i32 noundef 1)
; CHECK-NEXT:    ret void
;
  %l0 = load i32, ptr @GInt4
  call void @useI32(i32 %l0)
  store i32 1, ptr @GInt4
  %l1 = load i32, ptr @GInt4
  call void @useI32(i32 %l1)
  br i1 %c, label %T, label %F
T:
  store i32 %v, ptr @GInt4
  %l2 = load i32, ptr @GInt4
  call void @useI32(i32 %l2)
  br label %F
F:
  %l3 = load i32, ptr @GInt4
  call void @useI32(i32 %l3)
  store i32 1, ptr @GInt4
  %l4 = load i32, ptr @GInt4
  call void @useI32(i32 %l4)
  ret void
}

; TODO: In this test we can replace %l0, in the others above we cannot.
define void @entry5(i1 %c, i32 %v) {
; CHECK-LABEL: define {{[^@]+}}@entry5
; CHECK-SAME: (i1 [[C:%.*]], i32 [[V:%.*]]) {
; CHECK-NEXT:    [[L0:%.*]] = load i32, ptr @GInt5, align 4
; CHECK-NEXT:    call void @useI32(i32 [[L0]])
; CHECK-NEXT:    store i32 1, ptr @GInt5, align 4
; CHECK-NEXT:    call void @useI32(i32 noundef 1) #[[ATTR3:[0-9]+]]
; CHECK-NEXT:    br i1 [[C]], label [[T:%.*]], label [[F:%.*]]
; CHECK:       T:
; CHECK-NEXT:    store i32 [[V]], ptr @GInt5, align 4
; CHECK-NEXT:    call void @useI32(i32 [[V]]) #[[ATTR3]]
; CHECK-NEXT:    br label [[F]]
; CHECK:       F:
; CHECK-NEXT:    [[L3:%.*]] = load i32, ptr @GInt5, align 4
; CHECK-NEXT:    call void @useI32(i32 [[L3]]) #[[ATTR3]]
; CHECK-NEXT:    store i32 1, ptr @GInt5, align 4
; CHECK-NEXT:    call void @useI32(i32 noundef 1) #[[ATTR3]]
; CHECK-NEXT:    ret void
;
  %l0 = load i32, ptr @GInt5
  call void @useI32(i32 %l0)
  store i32 1, ptr @GInt5
  %l1 = load i32, ptr @GInt5
  call void @useI32(i32 %l1) nocallback
  br i1 %c, label %T, label %F
T:
  store i32 %v, ptr @GInt5
  %l2 = load i32, ptr @GInt5
  call void @useI32(i32 %l2) nocallback
  br label %F
F:
  %l3 = load i32, ptr @GInt5
  call void @useI32(i32 %l3) nocallback
  store i32 1, ptr @GInt5
  %l4 = load i32, ptr @GInt5
  call void @useI32(i32 %l4) nocallback
  ret void
}
;.
; CHECK: attributes #[[ATTR0:[0-9]+]] = { inaccessiblememonly nocallback nofree nosync nounwind willreturn }
; CHECK: attributes #[[ATTR1]] = { nofree norecurse nosync nounwind willreturn writeonly }
; CHECK: attributes #[[ATTR2]] = { nounwind writeonly }
; CHECK: attributes #[[ATTR3]] = { nocallback }
;.
